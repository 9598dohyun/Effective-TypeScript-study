2장 타입스트립트의 타입 시스템

아이템6.편집기를 사용하여 타입시스템 탐색하기
타입스크립트는 컴파일러 실행도 목적이지만 언어 서비스를 제공을 한다.
언어서비스는 코드의 자동완성,검색,리팩토링, 명세검사가 포함 될 뿐만 아니라 타입추론을 가능하게 해줍니다

```
const Num =(a:number,b:number)=>{
  return a+b;
}
//일때 반환타입이 없어도 알아서 number로 추론이 가능하다.
```

언어서비스는 라이브러리와 라이브러리 타입 선언을 탐색할 때 도움이 된다.

아이템7. 타입이 값들의 집합이라 생각하기
타입이란 할당 가능한 값들의 집합
가장 작은 집합은 아무 값도 포함되지 않는 공집합 타입스크립트에서는 never이다 즉 아무 값도 할당 불가능

가장작은단위 -never
한가지 값만 포함하는 타입 - 유닛타입 =리터럴 타입

타입체커의 역할 중 하나? 하나의 집합이 다른 집합의 부분 집합인지 검사하는 것

> 타입을 집합의 관점에서 바라보기

추가적으로 집합에 대한 시각으로 볼 때 유니온타입과 구조적타입이 다릅니다.

```
keyof (A&B) = (keyof A) | (keyof B) //구조적 타입
keyof (A|B) = (keyof A) & (keyof B) //유니온타입
```

자세히 살펴봅시다.</br> 1.구조적 타입에서의 교집합이란?

```
interface A {
name: string
}

interface B {
age: number
gender: string
}
```

이라는 타입이 2개있을 때
각각

```
const AB = A & B
const CD = key of(C|D)
```

라고 할 때 과연 둘의 값이 어떻게 나올까요?

```
interface AB {
name: string
age: number
gender: string
}

interface CD 는 never가 나옵니다
```

왜 이런일이 일어날까요?<br/>
&연산자는 두 타입의 인터섹션을 계산합니다.
const AB = A & B에서 &는 교집합이라 공통된 것을 가져와야 할 것 같지만 구조적타이핑에 따르면 AB가 A 와 B의 타입에도 속해야 한다는 뜻입니다.</br> 즉 A와B의 속성들을 다 가지면 문제가 양쪽의 타입을 갖게 되어 오류가 나오지 않습니다.</br> 그래서 &는 공통된 것을 찾는 것이 아닌 구조적타이핑에 의해 두 타입의 모든 것을 포함한 타입이 나오게됩니다</br>
이것이 타입관점에서의 교집합입니다.</br>
인터섹션 타입의 값은 각 타입 내의 속성을 모두 포함하는 것이 일반적인 규칙입니다.

const CD는 위와 반대로 never가 나옵니다.</br> 이유는 어떤 타입이 A에 속하거나 B에 속해야한다는 뜻인데 위에 예시에서는 두개의 타입이 될 수 있는 속성이 아무것도 없습니다.</br>그래서 never가 나오게 됩니다.</br>

만약 타입가드를 쓴다면 하나의 타입만 이용하기에 상관이 없지만 만약 그대로 유니온타입만을 쓴다면 함수는 어느타입이 들어올 지 알 수없어 공통된 것만을 가져와 오류가 안나오도록 하는 것입니다.</br>

결론적으로 이렇게 되는 이유는 자바스크립트의 구조적 타이핑을 타입스크립트가 모델링했기 때문입니다.</br>

또한 이러한 이유로 유니온 타입에서는 extneds를 사용할 수 없습니다.</br>

```

interface Vector1D { x: number; }
interface Vector2D { x: number; y: number; }
interface Vector3D { x: number; y: number; z: number; }
```

는

```

interface Vector1D { x: number; }
interface Vector2D extends Vector1D { y: number; }
interface Vector3D extends Vector2D { z: number; }
```

와 같습니다

원을 그려보면 가장 위에 vector1이 있고 그 밑에 vector2 vector3가 있는 것입니다 왜냐하면 vector1안에는 여러가지 속성들이 있을 수 있고 vector1만 만족시키면 추가적인 속성을 가져도 vector1에 해당하기 때문입니다.

서브타입이란?
어떤 집합이 다른 집합의 부분집합이라는 의미.

아이템8 타입공간과 값 공간의 심벌 구분하기
타입스크립트의 심벌은 타입 공간이나 값 공간 중의 한곳에 존재합니다.
속하는 공간에 따라 값또는 타입으로 쓸 수 있다.

```
interface Cylinder{
  radius: number;
  height: number;
}

const Cylinder = (radius:number , height:number)=>({radius,height})
```

위의 예시를 보면 같은이름이지만 타입으로써의 Cylinder와 함수로써의 Cylinder가 존재 할 수 있습니다.

구별하는 법

| 타입                                               | 값                           |
| -------------------------------------------------- | ---------------------------- |
| 앞에 type,interface가 붙는다                       | 앞에 const,let이 붙는다      |
| 타입선언(:),타입 단언(as}다음에 나오는 심벌은 타입 | = 다음에 나오는 모든 겂은 값 |

```
type T1 :'string' //타입
const V1 = 123 //  값

interface Person{
  first: string;
  last:string;
}

const p:Person ={first:'Jane',last:'Jacobs'};
//    -         --------------------------- 값
//      ------                              타입
```

- playground에서 확인을 할 수 있다

단 class , enum은 값과 타입 두가지 모두 가능한 예약어입니다
연산자 중에서도 typeof는 타입과 값에서 이용시 다른 기능을 합니다.
타입에 관점에서는 typeof는 값을 읽어서 타입스크립트 타입을 반환합니다
값의 관점에서는 자바스크립트 런타임의 typeof연산자가 됩니다.

아이템9 타입단언보다 타입선언 이용하기

```
interface Person{
  name:string
}

const Alice:Person ={name:Alice}; //타입 선언
const Bob ={name:Bob} as Person //타입 단언
```

타입단언은 강제로 그 타입을 주는 것이라서 만약 실제 타입과 다르더라도 오류를 표시하지 않습니다.
